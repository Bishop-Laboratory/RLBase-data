---
title: "R-Loop Table Analysis"
author: "Henry Miller"
date: "7/28/2021"
output:
  html_document:
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: false 
    code_folding: hide
    theme: journal
    highlight: haddock
---

```{r setup, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::knit_hooks$set(optipng = knitr::hook_optipng)
knitr::opts_chunk$set(warning = FALSE, message = FALSE, 
                      cache = TRUE, optipng='', cache.lazy = FALSE,
                      echo = TRUE)
```

```{r libraries}
RLOOP_PEAKS <- list("RL by counts" = "analyses/RLoop_Table_Analysis/data/rloops/strategy.a__10bp__peaks.narrowPeak",
                    "RL by mean signal" = "analyses/RLoop_Table_Analysis/data/rloops/strategy.b__10bp__peaks.narrowPeak",
                    "RL by mean qval" = "analyses/RLoop_Table_Analysis/data/rloops/strategy.c__10bp__peaks.narrowPeak")
MAX_RL_SIZE <- 5000

library(magrittr)
library(tidyverse)
library(ChIPpeakAnno)
library(enrichR)
library(EnsDb.Hsapiens.v86)
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
library(ChIPseeker)
# Annotations
annoData <- toGRanges(EnsDb.Hsapiens.v86, feature = "gene")
# TSS region
tss <- getPromoters(TxDb=TxDb.Hsapiens.UCSC.hg38.knownGene, 
                    upstream=3000, 
                    downstream=3000)
# Annotation function
annoRL <- function(gr, max_rl_size) {
  gr <- gr[width(gr) < max_rl_size,]
  gr <- keepStandardChromosomes(gr, pruning.mode = "coarse")
  anno <- annotatePeakInBatch(myPeakList = gr, AnnotationData = annoData, 
                      output = "overlapping")
  anno <- anno[! is.na(anno$feature),]
  annodf <- as.data.frame(anno)
  mapping <- AnnotationDbi::select(EnsDb.Hsapiens.v86, 
                                   keys = keys(EnsDb.Hsapiens.v86), 
                                   columns = "SYMBOL")
  annodf <- left_join(annodf, mapping , by = c('feature' = "GENEID"))
  anno$SYMBOL <- annodf$SYMBOL 
  return(anno)
}

# Read RLoops
readRL <- function(x, max_rl_size) {
  readr::read_tsv(x, comment = "#", col_names = c(
    "seqnames", "start", "end", "name", "score", "strand", "signalValue", "pval", "qval", "peak"
  )) %>%
    dplyr::filter(end - start < max_rl_size) %>%
    as.data.frame() %>%
    toGRanges() 
}

urlExists <- function(url) {
  identical(
    httr::status_code(
      # Checks HEAD only due to size constraints
      httr::HEAD(
        url
      )
    ), 200L  # Checks if response is ok
  )
}


checkRLFSAnno <- function(genome) {
  return(
    urlExists(
      paste0(
        "https://rmapdb-data.s3.us-east-2.amazonaws.com/rlfs-beds/", 
        genome, ".rlfs.bed"
      )
    )
  )
}

getRLFSAnno <- function(genome) {
  
  # Check if annotations available first
  if (! checkRLFSAnno(genome)) {
    stop("No RLFS annotations available for ", genome)
  }
  
  # Return as a GRanges object
  return(
    regioneR::toGRanges(
      as.data.frame(
        suppressMessages(readr::read_tsv(
          paste0(
            "https://rmapdb-data.s3.us-east-2.amazonaws.com/rlfs-beds/", 
            genome, ".rlfs.bed"
          ),
          col_names = FALSE))
      )
    )
  )
}


```

# Overview

We evaluated the output from the various strategies used to generate a set of standardized Rloops.


## Results

```{r}
rloops <- lapply(RLOOP_PEAKS, readRL, max_rl_size=MAX_RL_SIZE)
# tagMatrixList <- lapply(
#   rloops, function(peaks) {
#     getTagMatrix(peaks, weightCol = "score", windows = tss)
#   }
# )
# peakAnnoList <- lapply(
#   rloops, function(peaks) {
#     annotatePeak(peaks, verbose = FALSE, TxDb = TxDb.Hsapiens.UCSC.hg38.knownGene)
#   }
# )
# geneLst <- lapply(rloops, function(gr) {
#   anno <- annoRL(gr, max_rl_size = MAX_RL_SIZE) %>% as.data.frame()
#   return(anno)
# })
```

```{r}
# plotAvgProf(tagMatrixList, xlim=c(-3000, 3000))
```
```{r}
# plotDistToTSS(peakAnnoList)
```

```{r}
# plotAnnoBar(peakAnnoList)
```




```{r}
sapply(rloops, function(x) {
  summary(width(x))
})

```


```{r}
sapply(rloops, function(x) {
  length(names(x))
})
```

```{r}
# rlol <- findOverlapsOfPeaks(rloops)
# makeVennDiagram(rlol)
```


```{r}
# rlfs_res <- lapply(rloops, analyzeRLFS, genome="hg38")
# 
# # Check RLFS, chrom_sizes, and mask
# RLFS <- getRLFSAnno("hg38")
# 
# # Prevent stranded assignment
# GenomicRanges::strand(RLFS) <- "*"
# RLFS <- GenomicRanges::reduce(RLFS)
# 
# pt <- regioneR::permTest(A=rloops$`RL by counts`, B=RLFS, 
#                          genome="hg38",
#                          randomize.function=regioneR::circularRandomizeRegions,
#                          evaluate.function=regioneR::numOverlaps, verbose = T
#                          # alternative = "greater"
#                          )
# 
# z <- regioneR::localZScore(A=rloops$`RL by counts`, B=RLFS, pt, window = 5000, step = 50)
# 
# rloopsRLFS <- rloops
# rloopsRLFS[["RLFS"]] <- RLFS
# 
# rlrlfsol <- findOverlapsOfPeaks(rloopsRLFS)
# makeVennDiagram(rlrlfsol)

```

```{r}
# rloopsRLFS$`RL by counts`
# rlbcrlfsol <- findOverlapsOfPeaks(rloopsRLFS[c("RL by counts", "RLFS")])
# makeVennDiagram(rlbcrlfsol)
```



```{r}
rloops$`RL by counts`$names <- names(rloops$`RL by counts`)
olNames <- unlist(rlbcrlfsol$peaklist$`RL by counts///RLFS`$peakNames) %>%
  gsub(pattern = ".+__(rloops\\..+)", replacement = "\\1")
rloops$`RL by counts` %>%
  as_tibble() %>%
  rownames_to_column(var = "id") %>%
  mutate(id = paste0("RL", id),
         type = "Unknown",
         location = paste0(seqnames, ":", start, "-", end, ":", strand),
         confidence_level = score,
         is_rlfs = case_when(
           names %in% !! olNames ~ TRUE,
           TRUE ~ FALSE
         )) %>%
  dplyr::select(id, type, location, confidence_level, is_rlfs) %>%
  write_csv("analyses/RLoop_Table_Analysis/rloops.csv")
system("xz analyses/RLoop_Table_Analysis/rloops.csv")

```







